{"ast":null,"code":"/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n\n    /* eslint-disable no-var */\n\n    // TODO: Currently there's only a single priority level, Deferred. Will add\n    // additional priorities.\n    var DEFERRED_TIMEOUT = 5000;\n\n    // Callbacks are stored as a circular, doubly linked list.\n    var firstCallbackNode = null;\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    var timeRemaining;\n    if (hasNativePerformanceNow) {\n      timeRemaining = function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = getFrameDeadline() - performance.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    } else {\n      timeRemaining = function () {\n        // Fallback to Date.now()\n        var remaining = getFrameDeadline() - Date.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    }\n    var deadlineObject = {\n      timeRemaining: timeRemaining,\n      didTimeout: false\n    };\n    function ensureHostCallbackIsScheduled() {\n      if (isPerformingWork) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      }\n      // Schedule the host callback using the earliest timeout in the list.\n      var timesOutAt = firstCallbackNode.timesOutAt;\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelCallback();\n      }\n      requestCallback(flushWork, timesOutAt);\n    }\n    function flushFirstCallback(node) {\n      var flushedNode = firstCallbackNode;\n\n      // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = firstCallbackNode.next;\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var previous = firstCallbackNode.previous;\n        firstCallbackNode = previous.next = next;\n        next.previous = previous;\n      }\n      flushedNode.next = flushedNode.previous = null;\n\n      // Now it's safe to call the callback.\n      var callback = flushedNode.callback;\n      callback(deadlineObject);\n    }\n    function flushWork(didTimeout) {\n      isPerformingWork = true;\n      deadlineObject.didTimeout = didTimeout;\n      try {\n        if (didTimeout) {\n          // Flush all the timed out callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n            if (firstCallbackNode.timesOutAt <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n              continue;\n            }\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n          }\n        }\n      } finally {\n        isPerformingWork = false;\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled(firstCallbackNode);\n        } else {\n          isHostCallbackScheduled = false;\n        }\n      }\n    }\n    function unstable_scheduleWork(callback, options) {\n      var currentTime = exports.unstable_now();\n      var timesOutAt;\n      if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n        // Check for an explicit timeout\n        timesOutAt = currentTime + options.timeout;\n      } else {\n        // Compute an absolute timeout using the default constant.\n        timesOutAt = currentTime + DEFERRED_TIMEOUT;\n      }\n      var newNode = {\n        callback: callback,\n        timesOutAt: timesOutAt,\n        next: null,\n        previous: null\n      };\n\n      // Insert the new callback into the list, sorted by its timeout.\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled(firstCallbackNode);\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n        do {\n          if (node.timesOutAt > timesOutAt) {\n            // The new callback times out before this one.\n            next = node;\n            break;\n          }\n          node = node.next;\n        } while (node !== firstCallbackNode);\n        if (next === null) {\n          // No callback with a later timeout was found, which means the new\n          // callback has the latest timeout in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest timeout in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled(firstCallbackNode);\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n      return newNode;\n    }\n    function unstable_cancelScheduledWork(callbackNode) {\n      var next = callbackNode.next;\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      callbackNode.next = callbackNode.previous = null;\n    }\n\n    // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n    var localDate = Date;\n\n    // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n    // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n    // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n    var requestAnimationFrameWithTimeout = function (callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n    var requestCallback;\n    var cancelCallback;\n    var getFrameDeadline;\n    if (typeof window === 'undefined') {\n      // If this accidentally gets imported in a non-browser environment, fallback\n      // to a naive implementation.\n      var timeoutID = -1;\n      requestCallback = function (callback, absoluteTimeout) {\n        timeoutID = setTimeout(callback, 0, true);\n      };\n      cancelCallback = function () {\n        clearTimeout(timeoutID);\n      };\n      getFrameDeadline = function () {\n        return 0;\n      };\n    } else if (window._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var impl = window._schedMock;\n      requestCallback = impl[0];\n      cancelCallback = impl[1];\n      getFrameDeadline = impl[2];\n    } else {\n      if (typeof console !== 'undefined') {\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n      var scheduledCallback = null;\n      var isIdleScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isPerformingIdleWork = false;\n      var frameDeadline = 0;\n      // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      getFrameDeadline = function () {\n        return frameDeadline;\n      };\n\n      // We use the postMessage trick to defer idle work until after the repaint.\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n      var idleTick = function (event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n        isIdleScheduled = false;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            }\n            // Exit without invoking the callback.\n            return;\n          }\n        }\n        timeoutTime = -1;\n        var callback = scheduledCallback;\n        scheduledCallback = null;\n        if (callback !== null) {\n          isPerformingIdleWork = true;\n          try {\n            callback(didTimeout);\n          } finally {\n            isPerformingIdleWork = false;\n          }\n        }\n      };\n      // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n      window.addEventListener('message', idleTick, false);\n      var animationTick = function (rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          }\n          // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n      requestCallback = function (callback, absoluteTimeout) {\n        scheduledCallback = callback;\n        timeoutTime = absoluteTimeout;\n        if (isPerformingIdleWork) {\n          // If we're already performing idle work, an error must have been thrown.\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          window.postMessage(messageKey, '*');\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n      cancelCallback = function () {\n        scheduledCallback = null;\n        isIdleScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n    exports.unstable_scheduleWork = unstable_scheduleWork;\n    exports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","DEFERRED_TIMEOUT","firstCallbackNode","isPerformingWork","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","timeRemaining","remaining","getFrameDeadline","Date","deadlineObject","didTimeout","ensureHostCallbackIsScheduled","timesOutAt","cancelCallback","requestCallback","flushWork","flushFirstCallback","node","flushedNode","next","previous","callback","currentTime","unstable_now","unstable_scheduleWork","options","undefined","timeout","newNode","unstable_cancelScheduledWork","callbackNode","localDate","localSetTimeout","setTimeout","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","window","timeoutID","absoluteTimeout","_schedMock","impl","console","error","scheduledCallback","isIdleScheduled","timeoutTime","isAnimationFrameScheduled","isPerformingIdleWork","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","idleTick","event","source","data","animationTick","addEventListener","rafTime","nextFrameTime","postMessage"],"sources":["C:/Users/USER/Desktop/phonegenerator/node_modules/schedule/cjs/schedule.development.js"],"sourcesContent":["/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Currently there's only a single priority level, Deferred. Will add\n// additional priorities.\nvar DEFERRED_TIMEOUT = 5000;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest timeout in the list.\n  var timesOutAt = firstCallbackNode.timesOutAt;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelCallback();\n  }\n  requestCallback(flushWork, timesOutAt);\n}\n\nfunction flushFirstCallback(node) {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var previous = firstCallbackNode.previous;\n    firstCallbackNode = previous.next = next;\n    next.previous = previous;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  callback(deadlineObject);\n}\n\nfunction flushWork(didTimeout) {\n  isPerformingWork = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the timed out callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.timesOutAt <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    } else {\n      isHostCallbackScheduled = false;\n    }\n  }\n}\n\nfunction unstable_scheduleWork(callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var timesOutAt;\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n    // Check for an explicit timeout\n    timesOutAt = currentTime + options.timeout;\n  } else {\n    // Compute an absolute timeout using the default constant.\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\n  }\n\n  var newNode = {\n    callback: callback,\n    timesOutAt: timesOutAt,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, sorted by its timeout.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled(firstCallbackNode);\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.timesOutAt > timesOutAt) {\n        // The new callback times out before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later timeout was found, which means the new\n      // callback has the latest timeout in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest timeout in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelScheduledWork(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestCallback;\nvar cancelCallback;\nvar getFrameDeadline;\n\nif (typeof window === 'undefined') {\n  // If this accidentally gets imported in a non-browser environment, fallback\n  // to a naive implementation.\n  var timeoutID = -1;\n  requestCallback = function (callback, absoluteTimeout) {\n    timeoutID = setTimeout(callback, 0, true);\n  };\n  cancelCallback = function () {\n    clearTimeout(timeoutID);\n  };\n  getFrameDeadline = function () {\n    return 0;\n  };\n} else if (window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestCallback = impl[0];\n  cancelCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else {\n  if (typeof console !== 'undefined') {\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isPerformingIdleWork = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledCallback;\n    scheduledCallback = null;\n    if (callback !== null) {\n      isPerformingIdleWork = true;\n      try {\n        callback(didTimeout);\n      } finally {\n        isPerformingIdleWork = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestCallback = function (callback, absoluteTimeout) {\n    scheduledCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isPerformingIdleWork) {\n      // If we're already performing idle work, an error must have been thrown.\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelCallback = function () {\n    scheduledCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_scheduleWork = unstable_scheduleWork;\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}